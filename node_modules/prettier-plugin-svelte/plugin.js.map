{"version":3,"file":"plugin.js","sources":["src/lib/elements.ts","src/print/helpers.ts","src/lib/extractAttributes.ts","src/lib/getText.ts","src/options.ts","src/lib/snipTagContent.ts","src/print/node-helpers.ts","src/print/doc-helpers.ts","src/print/index.ts","src/embed.ts","src/index.ts"],"sourcesContent":["export type TagName = keyof HTMLElementTagNameMap | 'svg';\n\n// @see http://xahlee.info/js/html5_non-closing_tag.html\nexport const selfClosingTags = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements#Elements\nexport const inlineElements: TagName[] = [\n  'a',\n  'abbr',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'br',\n  'button',\n  'canvas',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'embed',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'object',\n  'output',\n  'picture',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'select',\n  'slot',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'svg',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'var',\n  'video',\n  'wbr'\n];\n\n/**\n * HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)\n */\nexport const formattableAttributes: string[] = [\n  // None at the moment\n  // Prettier HTML does not format attributes at all\n  // and to be consistent we leave this array empty for now\n]\n","import { ASTNode, Node } from './nodes';\nimport { FastPath } from 'prettier';\nimport { formattableAttributes } from '../lib/elements';\n\n/**\n * Determines whether or not given node\n * is the root of the Svelte AST.\n */\nexport function isASTNode(n: any): n is ASTNode {\n    return n && n.__isRoot;\n}\n\nexport function isPreTagContent(path: FastPath): boolean {\n    const stack = path.stack as Node[];\n\n    return stack.some(\n        (node) =>\n            (node.type === 'Element' && node.name.toLowerCase() === 'pre') ||\n            (node.type === 'Attribute' && !formattableAttributes.includes(node.name)),\n    );\n}\n\nexport function flatten<T>(arrays: T[][]): T[] {\n    return ([] as T[]).concat.apply([], arrays);\n}\n","import { AttributeNode, TextNode } from '../print/nodes';\n\nexport function extractAttributes(html: string): AttributeNode[] {\n    const extractAttributesRegex = /<[a-z]+\\s*(.*?)>/i;\n    const attributeRegex = /([^\\s=]+)(?:=(\"|')(.*?)\\2)?/gi;\n\n    const [, attributesString] = html.match(extractAttributesRegex)!;\n\n    const attrs: AttributeNode[] = [];\n\n    let match: RegExpMatchArray | null;\n    while ((match = attributeRegex.exec(attributesString))) {\n        const [all, name, quotes, value] = match;\n        const attrStart = match.index!;\n\n        let valueNode: AttributeNode['value'];\n        if (!value) {\n            valueNode = true;\n        } else {\n            let valueStart = attrStart + name.length;\n            if (quotes) {\n                valueStart += 2;\n            }\n\n            valueNode = [\n                {\n                    type: 'Text',\n                    data: value,\n                    start: valueStart,\n                    end: valueStart + value.length,\n                } as TextNode,\n            ];\n        }\n\n        attrs.push({\n            type: 'Attribute',\n            name,\n            value: valueNode,\n            start: attrStart,\n            end: attrStart + all.length,\n        });\n    }\n\n    return attrs;\n}\n","import { ParserOptions } from 'prettier';\nimport { Node } from '../print/nodes';\n\nexport function getText(node: Node, options: ParserOptions) {\n    const leadingComments: Node[] = (node as any).leadingComments\n\n    return options.originalText.slice(\n        options.locStart(\n            // if there are comments before the node they are not included \n            // in the `start` of the node itself\n            leadingComments && leadingComments[0] || node,\n        ),\n        options.locEnd(node),\n    );\n}\n","import { SupportOption } from 'prettier';\n\ndeclare module 'prettier' {\n    interface RequiredOptions extends PluginOptions {}\n}\n\nexport interface PluginOptions {\n    svelteSortOrder: SortOrder;\n    svelteStrictMode: boolean;\n    svelteBracketNewLine: boolean;\n    svelteAllowShorthand: boolean;\n    svelteIndentScriptAndStyle: boolean;\n}\n\nexport const options: Record<keyof PluginOptions, SupportOption> = {\n    svelteSortOrder: {\n        type: 'choice',\n        default: 'scripts-styles-markup',\n        description: 'Sort order for scripts, styles, and markup',\n        choices: [\n            { value: 'scripts-styles-markup' },\n            { value: 'scripts-markup-styles' },\n            { value: 'markup-styles-scripts' },\n            { value: 'markup-scripts-styles' },\n            { value: 'styles-markup-scripts' },\n            { value: 'styles-scripts-markup' },\n        ],\n    },\n    svelteStrictMode: {\n        type: 'boolean',\n        default: false,\n        description: 'More strict HTML syntax: self-closed tags, quotes in attributes',\n    },\n    svelteBracketNewLine: {\n        type: 'boolean',\n        default: false,\n        description: 'Put the `>` of a multiline element on a new line',\n    },\n    svelteAllowShorthand: {\n        type: 'boolean',\n        default: true,\n        description:\n            'Option to enable/disable component attribute shorthand if attribute name and expressions are same',\n    },\n    svelteIndentScriptAndStyle: {\n        type: 'boolean',\n        default: true,\n        description:\n            'Whether or not to indent the code inside <script> and <style> tags in Svelte files',\n    },\n};\n\nexport type SortOrder =\n    | 'scripts-styles-markup'\n    | 'scripts-markup-styles'\n    | 'markup-styles-scripts'\n    | 'markup-scripts-styles'\n    | 'styles-markup-scripts'\n    | 'styles-scripts-markup';\n\nexport type SortOrderPart = 'scripts' | 'markup' | 'styles';\n\nconst sortOrderSeparator = '-';\n\nexport function parseSortOrder(sortOrder: SortOrder): SortOrderPart[] {\n    return sortOrder.split(sortOrderSeparator) as SortOrderPart[];\n}\n","export const snippedTagContentAttribute = '✂prettier:content✂'\n\nexport function snipTagContent(tagName: string, source: string, placeholder = ''): string {\n    const regex = new RegExp(`[\\\\s\\n]*<${tagName}([^]*?)>([^]*?)<\\/${tagName}>[\\\\s\\n]*`, 'gi');\n    return source.replace(regex, (_, attributes, content) => {\n        const encodedContent = Buffer.from(content).toString('base64');\n        return `<${tagName}${attributes} ${snippedTagContentAttribute}=\"${encodedContent}\">${placeholder}</${tagName}>`;\n    });\n}\n\nexport function hasSnippedContent(text: string) {\n    return text.includes(snippedTagContentAttribute);\n}\n\nexport function unsnipContent(text: string): string {\n    const regex = /(<\\w+.*?)\\s*✂prettier:content✂=\"(.*?)\">.*?(?=<\\/)/gi;\n\n    return text.replace(regex, (_, start, encodedContent) => {\n        const content = Buffer.from(encodedContent, 'base64').toString('utf8');\n        return `${start}>${content}`;\n    });\n}\n","import {\n    Node,\n    ElementNode,\n    TextNode,\n    AttributeNode,\n    MustacheTagNode,\n    AttributeShorthandNode,\n    HeadNode,\n    InlineComponentNode,\n    SlotNode,\n    TitleNode,\n    WindowNode,\n} from './nodes';\nimport { inlineElements, TagName } from '../lib/elements';\nimport { FastPath } from 'prettier';\nimport { isASTNode } from './helpers';\n\nconst unsupportedLanguages = ['coffee', 'coffeescript', 'pug', 'styl', 'stylus', 'sass'];\n\nexport function isInlineElement(node: Node) {\n    return node.type === 'Element' && inlineElements.includes(node.name as TagName);\n}\n\nexport function isWhitespaceChar(ch: string) {\n    return ' \\t\\n\\r'.indexOf(ch) >= 0;\n}\n\nexport function canBreakAfter(node: Node) {\n    switch (node.type) {\n        case 'Text':\n            return isWhitespaceChar(node.raw[node.raw.length - 1]);\n        case 'Element':\n            return !isInlineElement(node);\n        case 'IfBlock':\n        case 'EachBlock':\n        case 'MustacheTag':\n            return false;\n        default:\n            return true;\n    }\n}\n\nexport function canBreakBefore(node: Node) {\n    switch (node.type) {\n        case 'Text':\n            return isWhitespaceChar(node.raw[0]);\n        case 'Element':\n            return !isInlineElement(node);\n        case 'IfBlock':\n        case 'EachBlock':\n        case 'MustacheTag':\n            return false;\n        default:\n            return true;\n    }\n}\n\nexport function isInlineNode(node: Node): boolean {\n    switch (node.type) {\n        case 'Text':\n            const text = getUnencodedText(node);\n            const isAllWhitespace = text.trim() === '';\n\n            return !isAllWhitespace || text === '';\n        case 'MustacheTag':\n        case 'EachBlock':\n        case 'IfBlock':\n            return true;\n        case 'Element':\n            return isInlineElement(node);\n        default:\n            return false;\n    }\n}\n\nexport function isNodeWithChildren(node: Node): node is Node & { children: Node[] } {\n    return (node as any).children;\n}\n\nexport function getChildren(node: Node): Node[] {\n    return isNodeWithChildren(node) ? node.children : [];\n}\n\n/**\n * Returns the previous sibling node.\n */\nexport function getPreviousNode(path: FastPath): Node | undefined {\n    const node: Node = path.getNode();\n    let parent: Node = path.getParentNode();\n\n    if (isASTNode(parent)) {\n        parent = parent.html;\n    }\n\n    return getChildren(parent).find((child) => child.end === node.start);\n}\n\n/**\n * Did there use to be any embedded object (that has been snipped out of the AST to be moved)\n * at the specified position?\n */\nexport function doesEmbedStartAt(position: number, path: FastPath) {\n    const root = path.stack[0];\n    const embeds = [root.css, root.html, root.instance, root.js, root.module] as Node[];\n\n    return embeds.find((n) => n && n.start === position) != null;\n}\n\nexport function isEmptyNode(node: Node): boolean {\n    return node.type === 'Text' && getUnencodedText(node).trim() === '';\n}\n\nexport function isIgnoreDirective(node: Node | undefined | null): boolean {\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore';\n}\n\nexport function printRaw(\n    node: ElementNode | InlineComponentNode | SlotNode | WindowNode | HeadNode | TitleNode,\n    originalText: string,\n): string {\n    if (node.children.length === 0) {\n        return '';\n    }\n\n    const firstChild = node.children[0];\n    const lastChild = node.children[node.children.length - 1];\n    return originalText.substring(firstChild.start, lastChild.end);\n}\n\nfunction isTextNode(node: Node): node is TextNode {\n    return node.type === 'Text';\n}\n\nfunction getAttributeValue(attributeName: string, node: Node) {\n    const attributes = (node as ElementNode)['attributes'] as AttributeNode[];\n\n    const langAttribute = attributes.find(\n        (attribute) => attribute.name === attributeName,\n    ) as AttributeNode | null;\n\n    return langAttribute && langAttribute.value;\n}\n\nexport function getAttributeTextValue(attributeName: string, node: Node): string | null {\n    const value = getAttributeValue(attributeName, node);\n\n    if (value != null && typeof value === 'object') {\n        const textValue = value.find(isTextNode);\n\n        if (textValue) {\n            return textValue.data;\n        }\n    }\n\n    return null;\n}\n\nfunction getLangAttribute(node: Node): string | null {\n    const value = getAttributeTextValue('lang', node) || getAttributeTextValue('type', node);\n\n    if (value != null) {\n        return value.replace(/^text\\//, '');\n    } else {\n        return null;\n    }\n}\n\n/**\n * Checks whether the node contains a `lang` attribute with a value corresponding to\n * a language we cannot format. This might for example be `<template lang=\"pug\">`.\n * If the node does not contain a `lang` attribute, the result is true.\n */\nexport function isNodeSupportedLanguage(node: Node) {\n    const lang = getLangAttribute(node);\n\n    return !(lang && unsupportedLanguages.includes(lang));\n}\n\nexport function isLoneMustacheTag(node: true | Node[]): node is [MustacheTagNode] {\n    return node !== true && node.length === 1 && node[0].type === 'MustacheTag';\n}\n\nexport function isAttributeShorthand(node: true | Node[]): node is [AttributeShorthandNode] {\n    return node !== true && node.length === 1 && node[0].type === 'AttributeShorthand';\n}\n\n/**\n * True if node is of type `{a}` or `a={a}`\n */\nexport function isOrCanBeConvertedToShorthand(node: AttributeNode): boolean {\n    if (isAttributeShorthand(node.value)) {\n        return true;\n    }\n\n    if (isLoneMustacheTag(node.value)) {\n        const expression = node.value[0].expression;\n        return expression.type === 'Identifier' && expression.name === node.name;\n    }\n\n    return false;\n}\n\nexport function getUnencodedText(node: TextNode) {\n    // `raw` will contain HTML entities in unencoded form\n    return node.raw || node.data;\n}\n","import { Doc, doc } from 'prettier';\n\nexport function isLine(doc: Doc) {    \n  return typeof doc === 'object' && doc.type === 'line' \n} \n\nexport function isLineDiscardedIfLonely(doc: Doc) {\n  return isLine(doc) && !(doc as doc.builders.Line).keepIfLonely\n}\n\n/**\n * Check if the doc is empty, i.e. consists of nothing more than empty strings (possibly nested).\n */\nexport function isEmptyDoc(doc: Doc): boolean {\n  if (typeof doc === 'string') {\n      return doc.length === 0;\n  }\n\n  if (doc.type === 'line') {\n      return !doc.keepIfLonely;\n  }\n\n  const { contents } = doc as { contents?: Doc };\n\n  if (contents) {\n      return isEmptyDoc(contents);\n  }\n\n  const { parts } = doc as { parts?: Doc[] };\n\n  if (parts) {\n      return isEmptyGroup(parts);\n  }\n\n  return false;\n}\n\nexport function isEmptyGroup(group: Doc[]): boolean {\n  return !group.find(doc => !isEmptyDoc(doc))\n}\n\n/**\n * Trims both leading and trailing nodes matching `isWhitespace` independent of nesting level\n * (though all trimmed adjacent nodes need to be a the same level). Modifies the `docs` array.\n */\nexport function trim(docs: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] {\n    trimLeft(docs, isWhitespace);\n    trimRight(docs, isWhitespace);\n\n    return docs;\n}\n\n/**\n * Trims the leading nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level)\n * and returnes the removed nodes.\n */\nexport function trimLeft(group: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] | undefined {\n    let firstNonWhitespace = group.findIndex((doc) => !isWhitespace(doc));\n\n    if (firstNonWhitespace < 0 && group.length) {\n        firstNonWhitespace = group.length;\n    }\n\n    if (firstNonWhitespace > 0) {\n        return group.splice(0, firstNonWhitespace);\n    } else {\n        const parts = getParts(group[0]);\n\n        if (parts) {\n            return trimLeft(parts, isWhitespace);\n        }\n    }\n}\n\n/**\n * Trims the trailing nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level)\n * and returnes the removed nodes.\n */\nexport function trimRight(group: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] | undefined {\n    let lastNonWhitespace = group.length ? findLastIndex((doc) => !isWhitespace(doc), group) : 0;\n\n    if (lastNonWhitespace < group.length - 1) {\n        return group.splice(lastNonWhitespace + 1);\n    } else {\n        const parts = getParts(group[group.length - 1]);\n\n        if (parts) {\n            return trimRight(parts, isWhitespace);\n        }\n    }\n}\n\nfunction getParts(doc: Doc): Doc[] | undefined {\n    if (typeof doc === 'object' && (doc.type === 'fill' || doc.type === 'concat')) {\n        return doc.parts;\n    }\n}\n\nfunction findLastIndex<T>(isMatch: (item: T) => boolean, items: T[]) {\n    for (let i = items.length - 1; i >= 0; i--) {\n        if (isMatch(items[i])) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n","import { FastPath, Doc, doc, ParserOptions } from 'prettier';\nimport { Node, IfBlockNode, AttributeNode } from './nodes';\nimport { isASTNode, isPreTagContent, flatten } from './helpers';\nimport { extractAttributes } from '../lib/extractAttributes';\nimport { getText } from '../lib/getText';\nimport { parseSortOrder, SortOrderPart } from '../options';\nimport { hasSnippedContent, unsnipContent } from '../lib/snipTagContent';\nimport { selfClosingTags, formattableAttributes } from '../lib/elements';\nimport {\n    canBreakBefore,\n    canBreakAfter,\n    isInlineElement,\n    isInlineNode,\n    isEmptyNode,\n    printRaw,\n    isNodeSupportedLanguage,\n    isLoneMustacheTag,\n    isOrCanBeConvertedToShorthand,\n    isIgnoreDirective,\n    doesEmbedStartAt,\n    getUnencodedText,\n} from './node-helpers';\nimport {\n    isLine,\n    isLineDiscardedIfLonely,\n    trim,\n    trimLeft,\n    trimRight,\n    isEmptyDoc,\n} from './doc-helpers';\n\nconst {\n    concat,\n    join,\n    line,\n    group,\n    indent,\n    dedent,\n    softline,\n    hardline,\n    fill,\n    breakParent,\n    literalline,\n} = doc.builders;\n\nexport type PrintFn = (path: FastPath) => Doc;\n\ndeclare module 'prettier' {\n    export namespace doc {\n        namespace builders {\n            interface Line {\n                keepIfLonely?: boolean;\n            }\n        }\n    }\n}\n\nlet ignoreNext = false;\n\nconst keepIfLonelyLine = { ...line, keepIfLonely: true, hard: true };\n\nexport function print(path: FastPath, options: ParserOptions, print: PrintFn): Doc {\n    const n = path.getValue();\n    if (!n) {\n        return '';\n    }\n\n    if (isASTNode(n)) {\n        const parts: doc.builders.Doc[] = [];\n        const addParts: Record<SortOrderPart, () => void> = {\n            scripts() {\n                if (n.module) {\n                    n.module.type = 'Script';\n                    n.module.attributes = extractAttributes(getText(n.module, options));\n                    parts.push(path.call(print, 'module'));\n                }\n                if (n.instance) {\n                    n.instance.type = 'Script';\n                    n.instance.attributes = extractAttributes(getText(n.instance, options));\n                    parts.push(path.call(print, 'instance'));\n                }\n            },\n            styles() {\n                if (n.css) {\n                    n.css.type = 'Style';\n                    n.css.content.type = 'StyleProgram';\n                    parts.push(path.call(print, 'css'));\n                }\n            },\n            markup() {\n                const htmlDoc = path.call(print, 'html');\n                if (htmlDoc) {\n                    parts.push(htmlDoc);\n                }\n            },\n        };\n        parseSortOrder(options.svelteSortOrder).forEach((p) => addParts[p]());\n        ignoreNext = false;\n        return group(join(hardline, parts));\n    }\n\n    const [open, close] = options.svelteStrictMode ? ['\"{', '}\"'] : ['{', '}'];\n    const node = n as Node;\n\n    if (ignoreNext && (node.type !== 'Text' || !isEmptyNode(node))) {\n        ignoreNext = false;\n        return concat(\n            flatten(\n                options.originalText\n                    .slice(options.locStart(node), options.locEnd(node))\n                    .split('\\n')\n                    .map((o, i) => (i == 0 ? [o] : [literalline, o])),\n            ),\n        );\n    }\n\n    switch (node.type) {\n        case 'Fragment':\n            const children = node.children;\n\n            if (children.length === 0 || children.every(isEmptyNode)) {\n                return '';\n            }\n\n            if (!isPreTagContent(path)) {\n                return concat([...trim(printChildren(path, print), isLine), hardline]);\n            } else {\n                return concat(printChildren(path, print));\n            }\n        case 'Text':\n            if (!isPreTagContent(path)) {\n                if (isEmptyNode(node)) {\n                    return {\n                        /**\n                         * Empty (whitespace-only) text nodes are collapsed into a single `line`,\n                         * which will be rendered as a single space if this node's group fits on a\n                         * single line. This follows how vanilla HTML is handled both by browsers and\n                         * by Prettier core.\n                         */\n                        ...line,\n\n                        /**\n                         * A text node is considered lonely if it is in a group without other inline\n                         * elements, such as the line breaks between otherwise consecutive HTML tags.\n                         * Text nodes that are both empty and lonely are discarded unless they have at\n                         * least one empty line (i.e. at least two linebreak sequences). This is to\n                         * allow for flexible grouping of HTML tags in a particular indentation level,\n                         * and is similar to how vanilla HTML is handled in Prettier core.\n                         */\n                        keepIfLonely: /\\n\\r?\\s*\\n\\r?/.test(getUnencodedText(node)),\n                    };\n                }\n\n                /**\n                 * For non-empty text nodes each sequence of non-whitespace characters (effectively,\n                 * each \"word\") is joined by a single `line`, which will be rendered as a single space\n                 * until this node's current line is out of room, at which `fill` will break at the\n                 * most convenient instance of `line`.\n                 */\n                return fill(splitTextToDocs(getUnencodedText(node)));\n            } else {\n                return getUnencodedText(node);\n            }\n        case 'Element':\n        case 'InlineComponent':\n        case 'Slot':\n        case 'Window':\n        case 'Head':\n        case 'Title': {\n            const isSupportedLanguage = !(\n                node.name === 'template' && !isNodeSupportedLanguage(node)\n            );\n            const isEmpty = node.children.every((child) => isEmptyNode(child));\n\n            const isSelfClosingTag =\n                isEmpty &&\n                (!options.svelteStrictMode ||\n                    node.type !== 'Element' ||\n                    selfClosingTags.indexOf(node.name) !== -1);\n\n            // Order important: print attributes first\n            const attributes = path.map((childPath) => childPath.call(print), 'attributes');\n            let body: Doc;\n\n            if (isEmpty) {\n                body = '';\n            } else if (!isSupportedLanguage) {\n                body = printRaw(node, options.originalText);\n            } else if (isInlineElement(node) || isPreTagContent(path)) {\n                body = printIndentedPreservingWhitespace(path, print);\n            } else {\n                body = printIndentedWithNewlines(path, print);\n            }\n\n            return group(\n                concat([\n                    '<',\n                    node.name,\n\n                    indent(\n                        group(\n                            concat([\n                                node.type === 'InlineComponent' && node.expression\n                                    ? concat([\n                                          line,\n                                          'this=',\n                                          open,\n                                          printJS(path, print, 'expression'),\n                                          close,\n                                      ])\n                                    : '',\n                                ...attributes,\n                                options.svelteBracketNewLine\n                                    ? dedent(isSelfClosingTag ? line : softline)\n                                    : '',\n                            ]),\n                        ),\n                    ),\n\n                    ...(isSelfClosingTag\n                        ? [options.svelteBracketNewLine ? '' : ' ', `/>`]\n                        : ['>', body, `</${node.name}>`]),\n                ]),\n            );\n        }\n        case 'Options':\n        case 'Body':\n            return group(\n                concat([\n                    '<',\n                    node.name,\n\n                    indent(\n                        group(concat(path.map((childPath) => childPath.call(print), 'attributes'))),\n                    ),\n\n                    ' />',\n                ]),\n            );\n        case 'Identifier':\n            return node.name;\n        case 'AttributeShorthand': {\n            return node.expression.name;\n        }\n        case 'Attribute': {\n            if (isOrCanBeConvertedToShorthand(node)) {\n                if (options.svelteStrictMode) {\n                    return concat([line, node.name, '=\"{', node.name, '}\"']);\n                } else if (options.svelteAllowShorthand) {\n                    return concat([line, '{', node.name, '}']);\n                } else {\n                    return concat([line, node.name, '={', node.name, '}']);\n                }\n            } else {\n                if (node.value === true) {\n                    return concat([line, node.name]);\n                }\n\n                const quotes = !isLoneMustacheTag(node.value) || options.svelteStrictMode;\n                const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);\n                if (quotes) {\n                    return concat([line, node.name, '=', '\"', attrNodeValue, '\"']);\n                } else {\n                    return concat([line, node.name, '=', attrNodeValue]);\n                }\n            }\n        }\n        case 'MustacheTag':\n            return concat(['{', printJS(path, print, 'expression'), '}']);\n        case 'IfBlock': {\n            const def: Doc[] = [\n                '{#if ',\n                printJS(path, print, 'expression'),\n                '}',\n                printIndentedWithNewlines(path, print),\n            ];\n\n            if (node.else) {\n                def.push(path.call(print, 'else'));\n            }\n\n            def.push('{/if}');\n\n            return concat([group(concat(def)), breakParent]);\n        }\n        case 'ElseBlock': {\n            // Else if\n            const parent = path.getParentNode() as Node;\n\n            if (\n                node.children.length === 1 &&\n                node.children[0].type === 'IfBlock' &&\n                parent.type !== 'EachBlock'\n            ) {\n                const ifNode = node.children[0] as IfBlockNode;\n                const def: Doc[] = [\n                    '{:else if ',\n                    path.map((ifPath) => printJS(path, print, 'expression'), 'children')[0],\n                    '}',\n                    path.map((ifPath) => printIndentedWithNewlines(ifPath, print), 'children')[0],\n                ];\n\n                if (ifNode.else) {\n                    def.push(path.map((ifPath) => ifPath.call(print, 'else'), 'children')[0]);\n                }\n                return group(concat(def));\n            }\n\n            return group(concat(['{:else}', printIndentedWithNewlines(path, print)]));\n        }\n        case 'EachBlock': {\n            const def: Doc[] = [\n                '{#each ',\n                printJS(path, print, 'expression'),\n                ' as ',\n                printJS(path, print, 'context'),\n            ];\n\n            if (node.index) {\n                def.push(', ', node.index);\n            }\n\n            if (node.key) {\n                def.push(' (', printJS(path, print, 'key'), ')');\n            }\n\n            def.push('}', printIndentedWithNewlines(path, print));\n\n            if (node.else) {\n                def.push(path.call(print, 'else'));\n            }\n\n            def.push('{/each}');\n\n            return concat([group(concat(def)), breakParent]);\n        }\n        case 'AwaitBlock': {\n            const hasPendingBlock = node.pending.children.some((n) => !isEmptyNode(n));\n            const hasThenBlock = node.then.children.some((n) => !isEmptyNode(n));\n            const hasCatchBlock = node.catch.children.some((n) => !isEmptyNode(n));\n\n            let block = [];\n\n            if (!hasPendingBlock && hasThenBlock) {\n                block.push(\n                    group(\n                        concat([\n                            '{#await ',\n                            printJS(path, print, 'expression'),\n                            ' then',\n                            expandNode(node.value),\n                            '}',\n                        ]),\n                    ),\n                    indent(path.call(print, 'then')),\n                );\n            } else {\n                block.push(group(concat(['{#await ', printJS(path, print, 'expression'), '}'])));\n\n                if (hasPendingBlock) {\n                    block.push(indent(path.call(print, 'pending')));\n                }\n\n                if (hasThenBlock) {\n                    block.push(\n                        group(concat(['{:then', expandNode(node.value), '}'])),\n                        indent(path.call(print, 'then')),\n                    );\n                }\n            }\n\n            if (hasCatchBlock) {\n                block.push(\n                    group(concat(['{:catch', expandNode(node.error), '}'])),\n                    indent(path.call(print, 'catch')),\n                );\n            }\n\n            block.push('{/await}');\n\n            return group(concat(block));\n        }\n        case 'KeyBlock': {\n            const def: Doc[] = [\n                '{#key ',\n                printJS(path, print, 'expression'),\n                '}',\n                printIndentedWithNewlines(path, print),\n            ];\n\n            def.push('{/key}');\n\n            return concat([group(concat(def)), breakParent]);\n        }\n        case 'ThenBlock':\n        case 'PendingBlock':\n        case 'CatchBlock':\n            return concat([\n                softline,\n                ...trim(printChildren(path, print), isLine),\n                dedent(softline),\n            ]);\n        case 'EventHandler':\n            return concat([\n                line,\n                'on:',\n                node.name,\n                node.modifiers && node.modifiers.length\n                    ? concat(['|', join('|', node.modifiers)])\n                    : '',\n                node.expression\n                    ? concat(['=', open, printJS(path, print, 'expression'), close])\n                    : '',\n            ]);\n        case 'Binding':\n            return concat([\n                line,\n                'bind:',\n                node.name,\n                node.expression.type === 'Identifier' && node.expression.name === node.name\n                    ? ''\n                    : concat(['=', open, printJS(path, print, 'expression'), close]),\n            ]);\n        case 'Class':\n            return concat([\n                line,\n                'class:',\n                node.name,\n                node.expression.type === 'Identifier' && node.expression.name === node.name\n                    ? ''\n                    : concat(['=', open, printJS(path, print, 'expression'), close]),\n            ]);\n        case 'Let':\n            return concat([\n                line,\n                'let:',\n                node.name,\n                // shorthand let directives have `null` expressions\n                !node.expression ||\n                (node.expression.type === 'Identifier' && node.expression.name === node.name)\n                    ? ''\n                    : concat(['=', open, printJS(path, print, 'expression'), close]),\n            ]);\n        case 'DebugTag':\n            return concat([\n                '{@debug',\n                node.identifiers.length > 0\n                    ? concat([' ', join(', ', path.map(print, 'identifiers'))])\n                    : '',\n                '}',\n            ]);\n        case 'Ref':\n            return concat([line, 'ref:', node.name]);\n        case 'Comment': {\n            /**\n             * If there is no sibling node that starts right after us but the parent indicates\n             * that there used to be, that means that node was actually an embedded `<style>`\n             * or `<script>` node that was cut out.\n             * If so, the comment does not refer to the next line we will see.\n             * The `embed` function handles printing the comment in the right place.\n             */\n            if (doesEmbedStartAt(node.end, path)) {\n                return '';\n            } else if (isIgnoreDirective(node)) {\n                ignoreNext = true;\n            }\n\n            let text = node.data;\n\n            if (hasSnippedContent(text)) {\n                text = unsnipContent(text);\n            }\n\n            return group(concat(['<!--', text, '-->']));\n        }\n        case 'Transition':\n            const kind = node.intro && node.outro ? 'transition' : node.intro ? 'in' : 'out';\n            return concat([\n                line,\n                kind,\n                ':',\n                node.name,\n                node.modifiers && node.modifiers.length\n                    ? concat(['|', join('|', node.modifiers)])\n                    : '',\n                node.expression\n                    ? concat(['=', open, printJS(path, print, 'expression'), close])\n                    : '',\n            ]);\n        case 'Action':\n            return concat([\n                line,\n                'use:',\n                node.name,\n                node.expression\n                    ? concat(['=', open, printJS(path, print, 'expression'), close])\n                    : '',\n            ]);\n        case 'Animation':\n            return concat([\n                line,\n                'animate:',\n                node.name,\n                node.expression\n                    ? concat(['=', open, printJS(path, print, 'expression'), close])\n                    : '',\n            ]);\n        case 'RawMustacheTag':\n            return concat(['{@html ', printJS(path, print, 'expression'), '}']);\n        case 'Spread':\n            return concat([line, '{...', printJS(path, print, 'expression'), '}']);\n    }\n\n    console.error(JSON.stringify(node, null, 4));\n    throw new Error('unknown node type: ' + node.type);\n}\n\nfunction printAttributeNodeValue(\n    path: FastPath<any>,\n    print: PrintFn,\n    quotes: boolean,\n    node: AttributeNode,\n) {\n    const valueDocs = path.map((childPath) => childPath.call(print), 'value');\n\n    if (!quotes || !formattableAttributes.includes(node.name)) {\n        return concat(valueDocs);\n    } else {\n        return indent(group(concat(trim(valueDocs, isLine))));\n    }\n}\n\nfunction printChildren(path: FastPath, print: PrintFn): Doc[] {\n    let childDocs: Doc[] = [];\n    let currentGroup: { doc: Doc; node: Node }[] = [];\n    // the index of the last child doc we could add a linebreak after\n    let lastBreakIndex = -1;\n\n    const isPreformat = isPreTagContent(path);\n\n    /**\n     * Call when reaching a point where a linebreak is possible. Will\n     * put all `childDocs` since the last possible linebreak position\n     * into a `concat` to avoid them breaking.\n     */\n    function linebreakPossible() {\n        if (lastBreakIndex >= 0 && lastBreakIndex < childDocs.length - 1) {\n            childDocs = childDocs\n                .slice(0, lastBreakIndex)\n                .concat(concat(childDocs.slice(lastBreakIndex)));\n        }\n\n        lastBreakIndex = -1;\n    }\n\n    /**\n     * Add a document to the output.\n     * @param childDoc undefined means do not add anything but allow for the possibility of a linebreak here.\n     * @param fromNode the Node the doc was generated from. undefined if childDoc is undefined.\n     */\n    function outputChildDoc(childDoc?: Doc, fromNode?: Node) {\n        if (!isPreformat) {\n            if (!childDoc || !fromNode || canBreakBefore(fromNode)) {\n                linebreakPossible();\n\n                const lastChild = childDocs[childDocs.length - 1];\n\n                // separate children by softlines, but not if the children are already lines.\n                // one exception: allow for a line break before \"keepIfLonely\" lines because they represent an empty line\n                if (\n                    childDoc != null &&\n                    !isLineDiscardedIfLonely(childDoc) &&\n                    lastChild != null &&\n                    !isLine(lastChild)\n                ) {\n                    childDocs.push(softline);\n                }\n            }\n\n            if (lastBreakIndex < 0 && childDoc && fromNode && !canBreakAfter(fromNode)) {\n                lastBreakIndex = childDocs.length;\n            }\n        }\n\n        if (childDoc) {\n            childDocs.push(childDoc);\n        }\n    }\n\n    function lastChildDocProduced() {\n        // line breaks are ok after last child\n        outputChildDoc();\n    }\n\n    /**\n     * Sequences of inline nodes (currently, `TextNode`s and `MustacheTag`s) are collected into\n     * groups and printed as a single `Fill` doc so that linebreaks as a result of sibling block\n     * nodes (currently, all HTML elements) don't cause those inline sequences to break\n     * prematurely. This is particularly important for whitespace sensitivity, as it is often\n     * desired to have text directly wrapping a mustache tag without additional whitespace.\n     */\n    function flush() {\n        for (let { doc, node } of currentGroup) {\n            for (const childDoc of extractOutermostNewlines(doc)) {\n                outputChildDoc(childDoc, node);\n            }\n        }\n\n        currentGroup = [];\n    }\n\n    path.each((childPath) => {\n        const childNode = childPath.getValue() as Node;\n        const childDoc = childPath.call(print);\n\n        if (isInlineNode(childNode)) {\n            currentGroup.push({ doc: childDoc, node: childNode });\n        } else {\n            flush();\n\n            if (childDoc !== '') {\n                outputChildDoc(\n                    isLine(childDoc) ? childDoc : concat([breakParent, childDoc]),\n                    childNode,\n                );\n            }\n        }\n    }, 'children');\n\n    flush();\n    lastChildDocProduced();\n\n    return childDocs;\n}\n\n/**\n * Print the nodes in `path` indented and with leading and trailing newlines.\n */\nfunction printIndentedWithNewlines(path: FastPath, print: PrintFn): Doc {\n    return indent(\n        concat([softline, ...trim(printChildren(path, print), isLine), dedent(softline)]),\n    );\n}\n\n/**\n * Print the nodes in `path` indented but without adding any leading or trailing newlines.\n */\nfunction printIndentedPreservingWhitespace(path: FastPath, print: PrintFn) {\n    return indent(concat(dedentFinalNewline(printChildren(path, print))));\n}\n\n/**\n * Split the text into words separated by whitespace. Replace the whitespaces by lines,\n * collapsing multiple whitespaces into a single line.\n *\n * If the text starts or ends with multiple newlines, those newlines should be \"keepIfLonely\"\n * since we want double newlines in the output.\n */\nfunction splitTextToDocs(text: string): Doc[] {\n    let docs: Doc[] = text.split(/[\\t\\n\\f\\r ]+/);\n\n    docs = join(line, docs).parts.filter((s) => s !== '');\n\n    // if the text starts with two newlines, the first doc is already a newline. make it \"keepIfLonely\"\n    if (text.match(/^([\\t\\f\\r ]*\\n){2}/)) {\n        docs[0] = keepIfLonelyLine;\n    }\n\n    // if the text ends with two newlines, the last doc is already a newline. make it \"keepIfLonely\"\n    if (text.match(/(\\n[\\t\\f\\r ]*){2}$/)) {\n        docs[docs.length - 1] = keepIfLonelyLine;\n    }\n\n    return docs;\n}\n\n/**\n * If there is a trailing newline, pull it out and put it inside a `dedent`. This is used\n * when we want to preserve whitespace, but still indent the newline if there is one\n * (e.g. for `<b>1\\n</b>` the `</b>` will be on its own line; for `<b>1</b>` it can't\n * because it would introduce new whitespace)\n */\nfunction dedentFinalNewline(docs: Doc[]): Doc[] {\n    const trimmedRight = trimRight(docs, isLine);\n\n    if (trimmedRight) {\n        return [...docs, dedent(trimmedRight[trimmedRight.length - 1])];\n    } else {\n        return docs;\n    }\n}\n\n/**\n * Pull out any nested leading or trailing lines and put them at the top level.\n */\nfunction extractOutermostNewlines(doc: Doc): Doc[] {\n    const leadingLines: Doc[] = trimLeft([doc], isLine) || [];\n    const trailingLines: Doc[] = trimRight([doc], isLine) || [];\n\n    return [...leadingLines, ...(!isEmptyDoc(doc) ? [doc] : ([] as Doc[])), ...trailingLines];\n}\n\nfunction printJS(path: FastPath, print: PrintFn, name?: string) {\n    if (!name) {\n        path.getValue().isJS = true;\n        return path.call(print);\n    }\n\n    path.getValue()[name].isJS = true;\n    return path.call(print, name);\n}\n\nfunction expandNode(node): string {\n    if (node === null) {\n        return '';\n    }\n\n    if (typeof node === 'string') {\n        // pre-v3.20 AST\n        return ' ' + node;\n    }\n\n    switch (node.type) {\n        case 'ArrayPattern':\n            return ' [' + node.elements.map(expandNode).join(',').slice(1) + ']';\n        case 'AssignmentPattern':\n            return expandNode(node.left) + ' =' + expandNode(node.right);\n        case 'Identifier':\n            return ' ' + node.name;\n        case 'Literal':\n            return ' ' + node.raw;\n        case 'ObjectPattern':\n            return ' {' + node.properties.map(expandNode).join(',') + ' }';\n        case 'Property':\n            if (node.value.type === 'ObjectPattern') {\n                return ' ' + node.key.name + ':' + expandNode(node.value);\n            } else if (node.value.type === 'Identifier' && node.key.name !== node.value.name) {\n                return expandNode(node.key) + ':' + expandNode(node.value);\n            } else {\n                return expandNode(node.value);\n            }\n        case 'RestElement':\n            return ' ...' + node.argument.name;\n    }\n\n    console.error(JSON.stringify(node, null, 4));\n    throw new Error('unknown node type: ' + node.type);\n}\n","import { Doc, doc, FastPath, ParserOptions } from 'prettier';\nimport { getText } from './lib/getText';\nimport { snippedTagContentAttribute } from './lib/snipTagContent';\nimport { PrintFn } from './print';\nimport {\n    getAttributeTextValue,\n    isNodeSupportedLanguage,\n    isIgnoreDirective,\n    getPreviousNode,\n} from './print/node-helpers';\nimport { Node } from './print/nodes';\n\nconst {\n    builders: { concat, hardline, group, indent, literalline },\n    utils: { removeLines },\n} = doc;\n\nexport function embed(\n    path: FastPath,\n    print: PrintFn,\n    textToDoc: (text: string, options: object) => Doc,\n    options: ParserOptions,\n): Doc | null {\n    const node: Node = path.getNode();\n\n    if (node.isJS) {\n        try {\n            return removeLines(\n                textToDoc(forceIntoExpression(getText(node, options)), {\n                    parser: expressionParser,\n                    singleQuote: true,\n                }),\n            );\n        } catch (e) {\n            return getText(node, options);\n        }\n    }\n\n    const embedType = (tag: string, parser: 'typescript' | 'css', isTopLevel: boolean) =>\n        embedTag(\n            tag,\n            path,\n            (content) => formatBodyContent(content, parser, textToDoc, options),\n            print,\n            isTopLevel,\n        );\n\n    const embedScript = (isTopLevel: boolean) => embedType('script', 'typescript', isTopLevel);\n    const embedStyle = (isTopLevel: boolean) => embedType('style', 'css', isTopLevel);\n\n    switch (node.type) {\n        case 'Script':\n            return embedScript(true);\n        case 'Style':\n            return embedStyle(true);\n        case 'Element': {\n            if (node.name === 'script') {\n                return embedScript(false);\n            } else if (node.name === 'style') {\n                return embedStyle(false);\n            }\n        }\n    }\n\n    return null;\n}\n\nfunction forceIntoExpression(statement: string) {\n    // note the trailing newline: if the statement ends in a // comment,\n    // we can't add the closing bracket right afterwards\n    return `(${statement}\\n)`;\n}\n\nfunction expressionParser(text: string, parsers: any, options: any) {\n    const ast = parsers.babel(text, parsers, options);\n\n    return { ...ast, program: ast.program.body[0].expression };\n}\n\nfunction skipBlank(docs: Doc[]): number {\n    for (let i = docs.length - 1; i >= 0; i--) {\n        const doc = docs[i];\n        if (typeof doc !== 'string') {\n            if (doc.type === 'break-parent') {\n                continue;\n            }\n        }\n\n        return i;\n    }\n\n    return -1;\n}\n\nfunction nukeLastLine(doc: Doc): Doc {\n    if (typeof doc === 'string') {\n        return doc;\n    }\n\n    switch (doc.type) {\n        case 'concat':\n            const end = skipBlank(doc.parts);\n            if (end > -1) {\n                return concat([\n                    ...doc.parts.slice(0, end),\n                    nukeLastLine(doc.parts[end]),\n                    ...doc.parts.slice(end + 1),\n                ]);\n            }\n            break;\n        case 'line':\n            return '';\n    }\n\n    return doc;\n}\n\nfunction preformattedBody(str: string): Doc {\n    const firstNewline = /^[\\t\\f\\r ]*\\n/;\n    const lastNewline = /\\n[\\t\\f\\r ]*$/;\n\n    // If we do not start with a new line prettier might try to break the opening tag\n    // to keep it together with the string. Use a literal line to skip indentation.\n    return concat([literalline, str.replace(firstNewline, '').replace(lastNewline, ''), hardline]);\n}\n\nfunction getSnippedContent(node: Node) {\n    const encodedContent = getAttributeTextValue(snippedTagContentAttribute, node);\n\n    if (encodedContent) {\n        return Buffer.from(encodedContent, 'base64').toString('utf-8');\n    } else {\n        return '';\n    }\n}\n\nfunction formatBodyContent(\n    content: string,\n    parser: 'typescript' | 'css',\n    textToDoc: (text: string, options: object) => Doc,\n    options: ParserOptions,\n) {\n    const indentContent = options.svelteIndentScriptAndStyle;\n\n    try {\n        const indentIfDesired = (doc: Doc) => (indentContent ? indent(doc) : doc);\n\n        return concat([\n            indentIfDesired(concat([hardline, nukeLastLine(textToDoc(content, { parser }))])),\n            hardline,\n        ]);\n    } catch (error) {\n        if (process.env.PRETTIER_DEBUG) {\n            throw error;\n        }\n\n        // We will wind up here if there is a syntax error in the embedded code. If we throw an error,\n        // prettier will try to print the node with the printer. That will fail with a hard-to-interpret\n        // error message (e.g. \"Unsupported node type\", referring to `<script>`).\n        // Therefore, fall back on just returning the unformatted text.\n        console.error(error);\n\n        return preformattedBody(content);\n    }\n}\n\nfunction embedTag(\n    tag: string,\n    path: FastPath,\n    formatBodyContent: (content: string) => Doc,\n    print: PrintFn,\n    isTopLevel: boolean,\n) {\n    const node: Node = path.getNode();\n    const content = getSnippedContent(node);\n\n    const previousNode = getPreviousNode(path);\n    const previousComment = previousNode && previousNode.type === 'Comment' ? previousNode : null;\n\n    const body: Doc =\n        isNodeSupportedLanguage(node) && !isIgnoreDirective(previousComment)\n            ? content.trim() !== ''\n                ? formatBodyContent(content)\n                : hardline\n            : preformattedBody(content);\n\n    const attributes = concat(\n        path.map(\n            (childPath) =>\n                childPath.getNode().name !== snippedTagContentAttribute\n                    ? childPath.call(print)\n                    : '',\n            'attributes',\n        ),\n    );\n\n    let result: Doc = group(\n        concat(['<', tag, indent(group(attributes)), '>', body, '</', tag, '>']),\n    );\n\n    if (isTopLevel) {\n        // top level embedded nodes have been moved from their normal position in the\n        // node tree. if there is a comment referring to it, it must be recreated at\n        // the new position.\n        if (previousComment) {\n            result = concat(['<!--', previousComment.data, '-->', hardline, result, hardline]);\n        } else {\n            result = concat([result, hardline]);\n        }\n    }\n\n    return result;\n}\n","import { SupportLanguage, Parser, Printer } from 'prettier';\nimport { print } from './print';\nimport { ASTNode } from './print/nodes';\nimport { embed } from './embed';\nimport { snipTagContent } from './lib/snipTagContent';\n\nfunction locStart(node: any) {\n    return node.start;\n}\n\nfunction locEnd(node: any) {\n    return node.end;\n}\n\nexport const languages: Partial<SupportLanguage>[] = [\n    {\n        name: 'svelte',\n        parsers: ['svelte'],\n        extensions: ['.svelte'],\n        vscodeLanguageIds: ['svelte'],\n    },\n];\n\nexport const parsers: Record<string, Parser> = {\n    svelte: {\n        parse: (text) => {\n            try {\n                return <ASTNode>{ ...require(`svelte/compiler`).parse(text), __isRoot: true };\n            } catch (err) {\n                if (err.start != null && err.end != null) {\n                    // Prettier expects error objects to have loc.start and loc.end fields. \n                    // Svelte uses start and end directly on the error.\n                    err.loc = {\n                        start: err.start,\n                        end: err.end,\n                    };\n                }\n\n                throw err;\n            }\n        },\n        preprocess: (text) => {\n            text = snipTagContent('style', text);\n            text = snipTagContent('script', text, '{}');\n            return text.trim();\n        },\n        locStart,\n        locEnd,\n        astFormat: 'svelte-ast',\n    },\n};\n\nexport const printers: Record<string, Printer> = {\n    'svelte-ast': {\n        print,\n        embed,\n    },\n};\n\nexport { options } from './options';\n"],"names":["doc","options","concat","hardline","group","indent","literalline"],"mappings":"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"}